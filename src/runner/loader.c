#include <string.h>
#include <inttypes.h>

#include <elf.h>
#include <errno.h>
#include <sys/mman.h>

#include <webserver/logs.h>
#include <runner/spec.h>

/*
 * @brief Verifies that the fields of the ELF image header are compatible with x86-64 object generated by PeachPy.
 * @param[in] elf_header Pointer to the ELF image header for the object file to validate.
 * @param[in] image_size Size of the ELF image. This field is used to verify that section header table is within image bounds.
 */
static void check_image_header(const Elf64_Ehdr* elf_header, size_t image_size) {
	if (elf_header->e_ident[EI_MAG0] != ELFMAG0 ||
		elf_header->e_ident[EI_MAG1] != ELFMAG1 ||
		elf_header->e_ident[EI_MAG2] != ELFMAG2 ||
		elf_header->e_ident[EI_MAG3] != ELFMAG3)
	{
		log_fatal("invalid ELF magic: %02X %02X %02X %02X\n",
			elf_header->e_ident[EI_MAG0], elf_header->e_ident[EI_MAG1],
			elf_header->e_ident[EI_MAG2], elf_header->e_ident[EI_MAG3]);
	}
	if (elf_header->e_ident[EI_CLASS] != ELFCLASS64) {
		log_fatal("unsupported ELF class: %02X\n", elf_header->e_ident[EI_CLASS]);
	}
	if (elf_header->e_ident[EI_DATA] != ELFDATA2LSB) {
		log_fatal("unsupported ELF endianness: %02X\n", elf_header->e_ident[EI_DATA]);
	}
	if (elf_header->e_ident[EI_VERSION] != EV_CURRENT) {
		log_fatal("unsupported ELF version: %d\n", elf_header->e_ident[EI_VERSION]);
	}
	if (elf_header->e_ident[EI_OSABI] != ELFOSABI_SYSV) {
		log_fatal("unsupported OS ABI: %d\n", elf_header->e_ident[EI_OSABI]);
	}
	if (elf_header->e_ident[EI_ABIVERSION] != 0) {
		log_fatal("unsupported ABI version: %d\n", elf_header->e_ident[EI_ABIVERSION]);
	}
	if (elf_header->e_type != ET_REL) {
		log_fatal("unsupported ELF file type: %d\n", elf_header->e_type);
	}
	if (elf_header->e_machine != EM_X86_64) {
		log_fatal("unsupported machine type: %d\n", elf_header->e_machine);
	}
	if (elf_header->e_version != EV_CURRENT) {
		log_fatal("unsupported ELF version: %d\n", elf_header->e_version);
	}
	if (elf_header->e_entry != 0) {
		log_fatal("unexpected ELF entry point: 0x%016"PRIx64"\n", elf_header->e_entry);
	}
	if (elf_header->e_phoff != 0) {
		log_fatal("unexpected program header table offset: %"PRIu64"\n", elf_header->e_phoff);
	}
	if (elf_header->e_shoff > image_size) {
		log_fatal("invalid section header table offset: %"PRIu64"\n", elf_header->e_shoff);
	}
	if (elf_header->e_flags != 0) {
		log_fatal("unsupported processor-specific flags: 0x%08"PRIx32"\n", elf_header->e_flags);
	}
	if (elf_header->e_ehsize != sizeof(Elf64_Ehdr)) {
		log_fatal("invalid ELF header size: %"PRIu32"\n", elf_header->e_ehsize);
	}
	if (elf_header->e_phnum != 0) {
		log_fatal("unsupported number of program header entries: %"PRIu16"\n", elf_header->e_phnum);
	}
	if (elf_header->e_shentsize != sizeof(Elf64_Shdr)) {
		log_fatal("invalid section header size: %"PRIu16"\n", elf_header->e_shentsize);
	}
	if (elf_header->e_shnum == 0) {
		log_fatal("no section entries\n");
	}
	if (elf_header->e_shnum >= SHN_LORESERVE) {
		log_fatal("too many section header entries: %"PRIu16"\n", elf_header->e_shnum);
	}
	if (elf_header->e_shoff + elf_header->e_shnum * elf_header->e_shentsize > image_size) {
		log_fatal("section header table extends beyond image end\n");
	}
	if (elf_header->e_shstrndx > elf_header->e_shnum) {
		log_fatal("invalid section name string table section header table index: %"PRIu16"\n", elf_header->e_shstrndx);
	}
}

generic_function load_kernel(const void* elf_image, size_t image_size, const char* function_name) {
	if (image_size < sizeof(Elf64_Ehdr)) {
		log_fatal("invalid ELF image size: %zu\n", image_size);
	}
	const Elf64_Ehdr* elf_header = (const Elf64_Ehdr*) elf_image;
	check_image_header(elf_header, image_size);

	const Elf64_Shdr* text_section = NULL;
	for (size_t section_index = 0; section_index < elf_header->e_shnum; section_index++) {
		const Elf64_Shdr* elf_section = elf_image + elf_header->e_shoff + section_index * elf_header->e_shentsize;
		switch (elf_section->sh_type) {
			case SHT_PROGBITS:
				if (elf_section->sh_flags == (SHF_ALLOC | SHF_EXECINSTR)) {
					if (text_section == NULL) {
						text_section = elf_section;
					} else {
						log_fatal("ELF file contains multiple .text-like sections\n");
					}
				} else {
					log_fatal("ELF file contains unsupported progbits section\n");
				}
				break;
			case SHT_REL:
			case SHT_RELA:
				log_fatal("ELF file contains unsupported relocations section\n");
				break;
		}
	}
	if (text_section == NULL) {
		log_fatal("ELF file does not contain a .text section\n");
	}

	/* Check .text section */
	if (text_section->sh_offset > image_size) {
		log_fatal("invalid .text offset %"PRIu64": .text section starts after the image end\n", text_section->sh_offset);
	}

	/* Check .text section */
	if (text_section->sh_offset + text_section->sh_size > image_size) {
		log_fatal(".text section extends beyound the image end\n");
	}

	void* text_segment = mmap(NULL, text_section->sh_size, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
	if (text_segment == MAP_FAILED) {
		log_fatal(".could not allocate code segment: %s\n", strerror(errno));
	}

	memcpy(text_segment, elf_image + text_section->sh_offset, text_section->sh_size);

	/* TODO: apply relocations */

	if (mprotect(text_segment, text_section->sh_size, PROT_READ | PROT_EXEC) == -1) {
		log_fatal("could not make the code segment executable: %s\n", strerror(errno));
	}

	return (generic_function) text_segment;
}
